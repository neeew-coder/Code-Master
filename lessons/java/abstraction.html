<h2 class="text-2xl font-bold mb-4 text-red-500">🧠 Java Abstraction</h2>

<p class="mb-6 text-gray-700">
  <strong>Abstraction</strong> is the process of hiding implementation details and showing only essential features. In Java, abstraction is achieved using <code>abstract</code> classes and <code>interfaces</code>.
</p>
<h3 class="text-lg font-semibold text-red-500 mb-2">🎥 Video Tutorial</h3>
<div class="mb-6">
  <div class="relative pb-[40.25%] h-0 overflow-hidden rounded-lg shadow-md">
    <iframe class="absolute top-0 left-0 w-full h-full" src="https://www.youtube.com/embed/Lvnb83qt57g" title="Java Abstraction Explained | Code Bro" frameborder="0" allowfullscreen></iframe>
  </div>
  <p class="text-sm text-gray-600 mt-2">
    Video by <strong>Code Bro</strong> –  
    <a class="text-red-600 underline" href="https://www.youtube.com/watch?v=Lvnb83qt57g" target="_blank">Watch on YouTube</a><br>
    <strong>Java Abstraction Explained</strong> introduces how abstract classes and interfaces define essential behavior while hiding implementation — supporting modular, scalable design.
  </p>
</div>
<h3 class="text-lg font-semibold text-red-500 mb-2">📘 What You’ll Learn</h3>
<ul class="list-disc list-inside mb-4 text-gray-700">
  <li>What abstraction means in object-oriented programming</li>
  <li>How abstract classes define partial implementations</li>
  <li>How interfaces declare behavior without implementation</li>
  <li>How abstraction supports modularity, flexibility, and contract-based design</li>
  <li>How to implement interfaces and override abstract methods</li>
</ul>

<!-- Collapsible Explanation -->
<details class="mb-6">
  <summary class="text-red-500 font-semibold cursor-pointer">📘 Why Use Abstraction?</summary>
  <ul class="list-disc list-inside text-gray-700 mt-2 space-y-2">
    <li>Hide complex logic from the user</li>
    <li>Expose only relevant operations</li>
    <li>Enable flexible and scalable design</li>
    <li>Support multiple implementations</li>
  </ul>
</details>

<!-- Inline Execution Block 1 -->
<div data-preview data-lang="java" data-mode="inline" class="bg-white border border-red-300 rounded-lg p-4 shadow-sm space-y-4 mb-8">
  <h3 class="text-lg font-semibold text-red-500">🧪 Abstract Class</h3>
  <textarea class="bg-black text-red-300 p-3 rounded text-sm font-mono w-full h-48 resize-none overflow-auto">
// Java code here
abstract class Animal {
  abstract void makeSound();

  void sleep() {
    System.out.println("Sleeping...");
  }
}

class Dog extends Animal {
  void makeSound() {
    System.out.println("Dog barks");
  }
}

public class Main {
  public static void main(String[] args) {
    Animal a = new Dog();
    a.makeSound();
    a.sleep();
  }
}
  </textarea>
  <div class="output bg-gray-100 border border-red-300 rounded p-3 text-sm text-gray-700">
    Output will appear here.
  </div>
  <div class="text-right mt-2">
    <button class="bg-red-400 hover:bg-red-500 text-white font-semibold px-4 py-2 rounded">Run</button>
  </div>

  <details>
    <summary class="text-red-500 font-semibold cursor-pointer">🔍 Explanation</summary>
    <p class="text-gray-700 mt-2">
      The <code>Animal</code> class defines an abstract method <code>makeSound()</code> and a concrete method <code>sleep()</code>. The <code>Dog</code> class provides the implementation for <code>makeSound()</code>.
    </p>
  </details>
</div>

<!-- Inline Execution Block 2 -->
<div data-preview data-lang="java" data-mode="inline" class="bg-white border border-red-300 rounded-lg p-4 shadow-sm space-y-4 mb-8">
  <h3 class="text-lg font-semibold text-red-500">🔌 Interface-Based Abstraction</h3>
  <textarea class="bg-black text-red-300 p-3 rounded text-sm font-mono w-full h-48 resize-none overflow-auto">
// Java code here
interface Vehicle {
  void start();
}

class Car implements Vehicle {
  public void start() {
    System.out.println("Car starts");
  }
}

public class Main {
  public static void main(String[] args) {
    Vehicle v = new Car();
    v.start();
  }
}
  </textarea>
  <div class="output bg-gray-100 border border-red-300 rounded p-3 text-sm text-gray-700">
    Output will appear here.
  </div>
  <div class="text-right mt-2">
    <button class="bg-red-400 hover:bg-red-500 text-white font-semibold px-4 py-2 rounded">Run</button>
  </div>

  <details>
    <summary class="text-red-500 font-semibold cursor-pointer">🔍 Explanation</summary>
    <p class="text-gray-700 mt-2">
      The <code>Vehicle</code> interface defines the <code>start()</code> method. The <code>Car</code> class implements it, providing its own behavior. This is full abstraction — no implementation in the interface.
    </p>
  </details>
</div>

<!-- Real-World Analogy -->
<div class="bg-red-50 border-l-4 border-red-400 p-4 mb-6">
  <p class="text-gray-800">
    🧠 <strong>Analogy:</strong> Think of a TV remote. You press a button to change channels, but you don’t need to know how the signal is processed. That’s abstraction — exposing functionality, hiding complexity.
  </p>
</div>
<h3 class="text-lg font-semibold text-red-500 mb-2">🧠 Lesson Summary</h3>
<p class="text-gray-700 mb-4 text-sm">
  Abstraction in Java allows developers to define what an object does without specifying how it does it. Abstract classes can include both abstract and concrete methods, while interfaces declare method signatures only. This separation of concerns enables scalable, maintainable code and supports polymorphism through contract-based programming. It’s essential for designing flexible APIs and layered architectures.
</p>
<h3 class="text-lg font-semibold text-red-500 mb-2">🧪 Try It Yourself</h3>
<pre class="bg-gray-100 p-4 rounded text-sm overflow-x-auto text-gray-800 mb-4">
// AbstractionDemo.java
interface Shape {
  double area();
}

class Circle implements Shape {
  double radius;

  Circle(double radius) {
    this.radius = radius;
  }

  public double area() {
    return Math.PI * radius * radius;
  }
}

public class AbstractionDemo {
  public static void main(String[] args) {
    Shape s = new Circle(5);
    System.out.println("Area: " + s.area());
  }
}
</pre>