<h2 class="text-2xl font-bold mb-4 text-green-500">🌀 C# Polymorphism</h2>

<p class="mb-6 text-gray-700">
  Polymorphism allows objects to be treated as instances of their base type while executing behavior specific to their actual type. It enables flexible and extensible code through method overriding and interfaces.
</p>
<h3 class="text-lg font-semibold text-green-600 mb-2">🎥 Video Tutorial</h3>
<div class="mb-6">
  <div class="relative pb-[40.25%] h-0 overflow-hidden rounded-lg shadow-md">
    <iframe class="absolute top-0 left-0 w-full h-full" src="https://www.youtube.com/embed/nYCMW3kfTvs" title="C# Polymorphism Explained | Bro Code" frameborder="0" allowfullscreen></iframe>
  </div>
  <p class="text-sm text-gray-600 mt-2">
    Video by <strong>Bro Code</strong> –  
    <a class="text-green-600 underline" href="https://www.youtube.com/watch?v=nYCMW3kfTvs" target="_blank">Watch on YouTube</a><br>
    <strong>C# Polymorphism Explained</strong> introduces how objects can take many forms — enabling flexible method calls and dynamic behavior through inheritance and overriding.
  </p>
</div>
<h3 class="text-lg font-semibold text-green-600 mb-2">📘 What You’ll Learn</h3>
<ul class="list-disc list-inside mb-4 text-gray-700">
  <li>How polymorphism allows method calls to behave differently based on object type</li>
  <li>How to use <code>virtual</code> and <code>override</code> for runtime polymorphism</li>
  <li>How base class references can point to derived class objects</li>
  <li>How polymorphism supports extensibility and loose coupling</li>
  <li>How to apply polymorphism in real-world scenarios like UI rendering or game logic</li>
</ul>

<!-- Syntax Example -->
<div data-preview data-lang="csharp" data-mode="inline" class="bg-white border border-green-300 rounded-lg p-4 shadow-sm space-y-4 mb-8">
  <h3 class="text-lg font-semibold text-green-500">📄 Polymorphism Syntax</h3>
  <textarea class="bg-black text-green-300 p-3 rounded text-sm font-mono w-full h-80 resize-none overflow-auto">
using System;

namespace PolymorphismDemo {
    class Program {
        static void Main(string[] args) {
            Animal a1 = new Dog();
            Animal a2 = new Cat();

            a1.Speak(); // Dog barks
            a2.Speak(); // Cat meows
        }
    }

    class Animal {
        public virtual void Speak() {
            Console.WriteLine("Animal sound");
        }
    }

    class Dog : Animal {
        public override void Speak() {
            Console.WriteLine("Dog barks");
        }
    }

    class Cat : Animal {
        public override void Speak() {
            Console.WriteLine("Cat meows");
        }
    }
}
  </textarea>
  <div class="output bg-gray-100 border border-green-300 rounded p-3 text-sm text-gray-700">
    Output will appear here.
  </div>
  <div class="text-right mt-2">
    <button class="bg-green-400 hover:bg-green-500 text-white font-semibold px-4 py-2 rounded">Run</button>
  </div>

  <details>
    <summary class="text-green-500 font-semibold cursor-pointer">🔍 Explanation</summary>
    <ul class="list-disc list-inside text-gray-700 mt-2 space-y-2">
      <li><strong>virtual:</strong> Enables method overriding</li>
      <li><strong>override:</strong> Provides specialized behavior</li>
      <li><strong>Base reference:</strong> Calls overridden method at runtime</li>
      <li>Polymorphism allows flexible substitution of derived types</li>
    </ul>
  </details>
</div>

<!-- Analogy -->
<div class="bg-green-50 border-l-4 border-green-400 p-4 mb-6">
  <p class="text-gray-800">
    🧠 <strong>Analogy:</strong> Polymorphism is like a remote control — the same button triggers different actions depending on the device.
  </p>
</div>

<!-- Interface Example -->
<h3 class="text-lg font-semibold text-green-500 mt-6 mb-2">📚 Interface-Based Polymorphism</h3>

<div class="bg-gray-50 border-l-4 border-green-400 p-4 mb-4">
  <p class="text-gray-800 font-mono text-sm">
    interface IShape { void Draw(); }<br>
    class Circle : IShape { public void Draw() { Console.WriteLine("Circle"); } }<br>
    class Square : IShape { public void Draw() { Console.WriteLine("Square"); } }<br><br>
    IShape s = new Circle();<br>
    s.Draw(); // Circle
  </p>
</div>

<!-- Tips -->
<div class="bg-green-50 border-l-4 border-green-400 p-4 mb-6">
  <p class="text-gray-800">
    💡 <strong>Tips:</strong> Use polymorphism to decouple logic. Prefer interfaces for flexibility. Avoid tight coupling between base and derived classes.
  </p>
</div>
<h3 class="text-lg font-semibold text-green-600 mb-2">🧠 Lesson Summary</h3>
<p class="text-gray-700 mb-4 text-sm">
  Polymorphism in C# enables objects to respond differently to the same method call depending on their actual type. This tutorial shows how to use inheritance, virtual methods, and overrides to create flexible, extensible systems. It’s a cornerstone of object-oriented design, especially for dynamic behavior and interface-driven architecture.
</p>
<h3 class="text-lg font-semibold text-green-600 mb-2">🧪 Try It Yourself</h3>
<pre class="bg-gray-100 p-4 rounded text-sm overflow-x-auto text-gray-800 mb-4">
// PolymorphismDemo.cs
using System;

class Shape {
  public virtual void Draw() {
    Console.WriteLine("Drawing a shape");
  }
}

class Circle : Shape {
  public override void Draw() {
    Console.WriteLine("Drawing a circle");
  }
}

class Square : Shape {
  public override void Draw() {
    Console.WriteLine("Drawing a square");
  }
}

class Program {
  static void Main() {
    Shape[] shapes = { new Circle(), new Square() };
    foreach (Shape s in shapes) {
      s.Draw(); // Output depends on actual object type
    }
  }
}
</pre>