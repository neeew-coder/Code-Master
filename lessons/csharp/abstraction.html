<h2 class="text-2xl font-bold mb-4 text-green-500">🧠 C# Abstraction</h2>

<p class="mb-6 text-gray-700">
  Abstraction hides implementation details and exposes only essential features. It helps define contracts and enforce structure without revealing internal logic.
</p>
<h3 class="text-lg font-semibold text-green-600 mb-2">🎥 Video Tutorial</h3>
<div class="mb-6">
  <div class="relative pb-[40.25%] h-0 overflow-hidden rounded-lg shadow-md">
    <iframe class="absolute top-0 left-0 w-full h-full" src="https://www.youtube.com/embed/qgU2ojOKLP8" title="C# Abstraction Explained | tutorialsEU" frameborder="0" allowfullscreen></iframe>
  </div>
  <p class="text-sm text-gray-600 mt-2">
    Video by <strong>tutorialsEU - C#</strong> –  
    <a class="text-green-600 underline" href="https://www.youtube.com/watch?v=qgU2ojOKLP8" target="_blank">Watch on YouTube</a><br>
    <strong>C# Abstraction Explained</strong> introduces how to hide implementation details and expose essential behavior using abstract classes and interfaces.
  </p>
</div>
<h3 class="text-lg font-semibold text-green-600 mb-2">📘 What You’ll Learn</h3>
<ul class="list-disc list-inside mb-4 text-gray-700">
  <li>How abstraction simplifies complex systems by exposing only relevant functionality</li>
  <li>How to define <code>abstract</code> classes and methods</li>
  <li>How to implement interfaces to enforce contracts</li>
  <li>How abstraction supports loose coupling and testability</li>
  <li>How to use abstraction in real-world design like payment processors or shape renderers</li>
</ul>

<!-- Syntax Example -->
<div data-preview data-lang="csharp" data-mode="inline" class="bg-white border border-green-300 rounded-lg p-4 shadow-sm space-y-4 mb-8">
  <h3 class="text-lg font-semibold text-green-500">📄 Abstraction Syntax</h3>
  <textarea class="bg-black text-green-300 p-3 rounded text-sm font-mono w-full h-80 resize-none overflow-auto">
using System;

namespace AbstractionDemo {
    class Program {
        static void Main(string[] args) {
            Shape s = new Circle();
            s.Draw(); // Circle drawn
        }
    }

    abstract class Shape {
        public abstract void Draw(); // Abstract method
    }

    class Circle : Shape {
        public override void Draw() {
            Console.WriteLine("Circle drawn");
        }
    }
}
  </textarea>
  <div class="output bg-gray-100 border border-green-300 rounded p-3 text-sm text-gray-700">
    Output will appear here.
  </div>
  <div class="text-right mt-2">
    <button class="bg-green-400 hover:bg-green-500 text-white font-semibold px-4 py-2 rounded">Run</button>
  </div>

  <details>
    <summary class="text-green-500 font-semibold cursor-pointer">🔍 Explanation</summary>
    <ul class="list-disc list-inside text-gray-700 mt-2 space-y-2">
      <li><strong>abstract class:</strong> Cannot be instantiated</li>
      <li><strong>abstract method:</strong> Must be implemented by derived class</li>
      <li><strong>override:</strong> Provides concrete behavior</li>
      <li>Abstraction defines structure, not implementation</li>
    </ul>
  </details>
</div>

<!-- Analogy -->
<div class="bg-green-50 border-l-4 border-green-400 p-4 mb-6">
  <p class="text-gray-800">
    🧠 <strong>Analogy:</strong> Abstraction is like a remote control interface — you know what buttons do, but not how the device works internally.
  </p>
</div>

<!-- Interface Example -->
<h3 class="text-lg font-semibold text-green-500 mt-6 mb-2">📚 Interface-Based Abstraction</h3>

<div class="bg-gray-50 border-l-4 border-green-400 p-4 mb-4">
  <p class="text-gray-800 font-mono text-sm">
    interface IPrinter { void Print(); }<br>
    class LaserPrinter : IPrinter { public void Print() { Console.WriteLine("Laser print"); } }<br><br>
    IPrinter p = new LaserPrinter();<br>
    p.Print(); // Laser print
  </p>
</div>

<!-- Tips -->
<div class="bg-green-50 border-l-4 border-green-400 p-4 mb-6">
  <p class="text-gray-800">
    💡 <strong>Tips:</strong> Use abstract classes when partial implementation is shared. Use interfaces for pure contracts. Avoid exposing internal logic.
  </p>
</div>
<h3 class="text-lg font-semibold text-green-600 mb-2">🧠 Lesson Summary</h3>
<p class="text-gray-700 mb-4 text-sm">
  Abstraction in C# allows developers to define the “what” without the “how.” By using abstract classes and interfaces, you can expose essential operations while hiding internal logic. This tutorial shows how to design flexible, scalable systems that focus on behavior rather than implementation.
</p>
<h3 class="text-lg font-semibold text-green-600 mb-2">🧪 Try It Yourself</h3>
<pre class="bg-gray-100 p-4 rounded text-sm overflow-x-auto text-gray-800 mb-4">
// AbstractionDemo.cs
using System;

abstract class Animal {
  public abstract void MakeSound();
}

class Dog : Animal {
  public override void MakeSound() {
    Console.WriteLine("Woof!");
  }
}

class Program {
  static void Main() {
    Animal a = new Dog();
    a.MakeSound(); // Output: Woof!
  }
}
</pre>